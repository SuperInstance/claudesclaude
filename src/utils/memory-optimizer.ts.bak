/**
 * Memory Optimizer - Advanced memory management strategies
 */

import type { Session, Message } from '../core/types.js';

interface MemoryStats {
  totalSessions: number;
  totalMessages: number;
  totalContexts: number;
  estimatedMemoryUsage: number;
  overhead: number;
}

interface OptimizationStrategy {
  name: string;
  description: string;
  apply: (orchestrator: any) => void;
  benefit: string;
}

// Memory usage estimation
function estimateSessionMemory(session: Session): number {
  // Base session size + name + workspace + config
  return (
    64 + // Base object overhead
    session.name.length * 2 + // String storage
    session.workspace.length * 2 + // String storage
    JSON.stringify(session.config).length + // Config storage
    32 // Additional overhead
  );
}

function estimateMessageMemory(message: Message): number {
  // Message object + content + metadata
  return (
    48 + // Base object overhead
    message.content.length * 2 + // Content string
    (message.metadata ? JSON.stringify(message.metadata).length : 0) + // Metadata
    24 // Additional overhead
  );
}

export class MemoryOptimizer {
  private strategies: OptimizationStrategy[] = [
    {
      name: 'Session Pruning',
      description: 'Remove inactive sessions older than TTL',
      apply: (orchestrator: any) => {
        const sessions = orchestrator.getAllSessions();
        const now = Date.now();
        const maxAge = 24 * 60 * 60 * 1000; // 24 hours

        sessions.forEach(session => {
          if (now - session.createdAt.getTime() > maxAge && session.status === 'inactive') {
            orchestrator.deleteSession(session.id);
          }
        });
      },
      benefit: 'Removes stale sessions that are no longer needed'
    },
    {
      name: 'Message Buffer Optimization',
      description: 'Compact message buffer periodically',
      apply: (orchestrator: any) => {
        // Process accumulated messages
        const processed = orchestrator.processMessages();
        if (processed > 0) {
          console.log(`Optimized: Processed ${processed} messages`);
        }
      },
      benefit: 'Reduces memory usage from accumulated messages'
    },
    {
      name: 'Context Compression',
      description: 'Clear unused contexts',
      apply: (orchestrator: any) => {
        const sessions = orchestrator.getAllSessions();
        sessions.forEach(session => {
          // Clear contexts for sessions that haven't been used recently
          const context = orchestrator.getContext(session.id);
          if (context && !context.lastUsed) {
            orchestrator.setContext(session.id, null);
          }
        });
      },
      benefit: 'Frees up memory from unused context data'
    },
    {
      name: 'Cache Optimization',
      description: 'Adjust cache sizes based on usage patterns',
      apply: (orchestrator: any) => {
        const metrics = orchestrator.getMetrics();
        const utilization = metrics.activeSessions / 1000; // Assuming max 1000 sessions

        // If utilization is low, reduce cache size
        if (utilization < 0.3 && metrics.activeSessions < 300) {
          // This would require modifying the orchestrator's cache size
          // For now, we'll just log the recommendation
          console.log(`Recommendation: Consider reducing session cache size to ${Math.round(1000 * utilization)}`);
        }
      },
      benefit: 'Optimizes memory usage based on actual load'
    }
  ];

  // Calculate memory statistics
  calculateMemoryStats(orchestrator: any): MemoryStats {
    const sessions = orchestrator.getAllSessions();
    const messages = orchestrator.getMetrics().pendingMessages;
    const contexts = orchestrator.getMetrics().cachedContexts;

    let estimatedMemoryUsage = 0;

    sessions.forEach(session => {
      estimatedMemoryUsage += estimateSessionMemory(session);
    });

    // Estimate message memory
    estimatedMemoryUsage += messages * 100; // Average message size

    // Estimate context memory
    estimatedMemoryUsage += contexts * 50; // Average context size

    // Calculate overhead (Map objects, event handlers, etc.)
    const overhead = estimatedMemoryUsage * 0.2; // 20% overhead

    return {
      totalSessions: sessions.length,
      totalMessages: messages,
      totalContexts: contexts,
      estimatedMemoryUsage: Math.round(estimatedMemoryUsage),
      overhead: Math.round(overhead)
    };
  }

  // Apply all optimization strategies
  optimizeMemory(orchestrator: any): void {
    console.log('üßπ Applying memory optimization strategies...');

    this.strategies.forEach(strategy => {
      try {
        strategy.apply(orchestrator);
        console.log(`‚úÖ Applied: ${strategy.name} - ${strategy.benefit}`);
      } catch (error) {
        console.warn(`‚ö†Ô∏è  Failed to apply ${strategy.name}:`, error);
      }
    });

    const finalStats = this.calculateMemoryStats(orchestrator);
    console.log(`üìä Final memory usage: ${finalStats.estimatedMemoryUsage + finalStats.overhead} bytes`);
  }

  // Get optimization recommendations
  getRecommendations(orchestrator: any): string[] {
    const recommendations: string[] = [];
    const stats = this.calculateMemoryStats(orchestrator);
    const metrics = orchestrator.getMetrics();

    // Memory usage recommendations
    if (stats.estimatedMemoryUsage > 10 * 1024 * 1024) { // > 10MB
      recommendations.push('Consider implementing session expiration to reduce memory usage');
    }

    // Cache size recommendations
    if (metrics.activeSessions < 100 && metrics.cachedContexts < 50) {
      recommendations.push('Consider reducing cache sizes for better memory efficiency');
    }

    // Message buffer recommendations
    if (metrics.pendingMessages > 1000) {
      recommendations.push('Message buffer is growing, consider increasing processing frequency');
    }

    // Health check recommendations
    const health = orchestrator.healthCheck();
    if (health.status === 'degraded') {
      recommendations.push('System is degraded, consider scaling or reducing load');
    }

    return recommendations;
  }

  // Generate memory report
  generateMemoryReport(orchestrator: any): string {
    const stats = this.calculateMemoryStats(orchestrator);
    const metrics = orchestrator.getMetrics();
    const recommendations = this.getRecommendations(orchestrator);

    let report = 'üß† Memory Optimization Report\n';
    report += '='.repeat(50) + '\n\n';

    report += 'üìä Memory Statistics:\n';
    report += `  Sessions: ${stats.totalSessions}\n`;
    report += `  Messages: ${stats.totalMessages}\n`;
    report += `  Contexts: ${stats.totalContexts}\n`;
    report += `  Estimated Usage: ${stats.estimatedMemoryUsage} bytes\n`;
    report += `  Overhead: ${stats.overhead} bytes\n`;
    report += `  Total: ${(stats.estimatedMemoryUsage + stats.overhead).toLocaleString()} bytes\n\n`;

    report += 'üìà System Metrics:\n';
    report += `  Active Sessions: ${metrics.activeSessions}\n`;
    report += `  Total Messages: ${metrics.totalMessages}\n`;
    report += `  Pending Messages: ${metrics.pendingMessages}\n`;
    report += `  Memory Usage: ${metrics.memoryUsage} bytes\n\n`;

    report += 'üí° Optimization Recommendations:\n';
    if (recommendations.length > 0) {
      recommendations.forEach((rec, index) => {
        report += `${index + 1}. ${rec}\n`;
      });
    } else {
      report += '  No immediate recommendations - system is well-optimized\n';
    }

    report += '\nüîß Available Optimization Strategies:\n';
    this.strategies.forEach(strategy => {
      report += `  ‚Ä¢ ${strategy.name}: ${strategy.description}\n`;
    });

    return report;
  }

  // Continuous memory monitoring
  startMemoryMonitoring(orchestrator: any, intervalMs: number = 30000): void {
    console.log(`üîÑ Starting memory monitoring (interval: ${intervalMs}ms)...`);

    setInterval(() => {
      const stats = this.calculateMemoryStats(orchestrator);
      const health = orchestrator.healthCheck();

      console.log(`üìä Memory: ${(stats.estimatedMemoryUsage + stats.overhead).toLocaleString()} bytes | Health: ${health.status}`);

      if (health.status === 'unhealthy') {
        console.warn('‚ö†Ô∏è  Memory optimization needed!');
        this.optimizeMemory(orchestrator);
      }
    }, intervalMs);
  }
}

// Export singleton instance
export const memoryOptimizer = new MemoryOptimizer();