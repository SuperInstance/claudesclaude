/**
 * Performance Benchmark - Comprehensive testing of all orchestrator versions
 */

import { ultimateOrchestrator, hyperOrchestrator, microOrchestrator, ultraOrchestrator, orchestrator } from '../index.js';
import type { Message } from '../core/types.js';

interface BenchmarkResult {
  name: string;
  time: number;
  operations: number;
  opsPerSecond: number;
  memoryBefore: number;
  memoryAfter: number;
  memoryDelta: number;
}

interface BenchmarkSuite {
  name: string;
  results: BenchmarkResult[];
}

// Utility functions
function generateTestSession(type: string = 'agent', name: string = 'Test Session'): any {
  return {
    type: type as any,
    name,
    workspace: '/test',
    config: {}
  };
}

function generateTestMessage(id: string = 'msg-1'): Message {
  return {
    id,
    type: 'text' as any,
    content: 'Test message content',
    timestamp: new Date()
  };
}

// Memory measurement
function getMemoryUsage(): number {
  return process.memoryUsage ? process.memoryUsage().heapUsed : 0;
}

// Benchmark single operation
function benchmarkOperation(
  name: string,
  operation: () => void,
  iterations: number = 10000
): BenchmarkResult {
  const memoryBefore = getMemoryUsage();
  const startTime = performance.now();

  for (let i = 0; i < iterations; i++) {
    operation();
  }

  const endTime = performance.now();
  const memoryAfter = getMemoryUsage();

  return {
    name,
    time: endTime - startTime,
    operations: iterations,
    opsPerSecond: (iterations / (endTime - startTime)) * 1000,
    memoryBefore,
    memoryAfter,
    memoryDelta: memoryAfter - memoryBefore
  };
}

// Comprehensive benchmark suite
export class PerformanceBenchmark {
  private suites: BenchmarkSuite[] = [];

  // Session creation benchmark
  benchmarkSessionCreation(orchestrator: any, iterations: number = 10000): BenchmarkResult {
    return benchmarkOperation(
      'Session Creation',
      () => {
        orchestrator.createSession(generateTestSession());
      },
      iterations
    );
  }

  // Session retrieval benchmark
  benchmarkSessionRetrieval(orchestrator: any, iterations: number = 10000): BenchmarkResult {
    // Create sessions first
    const sessions = [];
    for (let i = 0; i < iterations; i++) {
      const session = orchestrator.createSession(generateTestSession());
      sessions.push(session.id);
    }

    return benchmarkOperation(
      'Session Retrieval',
      () => {
        const randomIndex = Math.floor(Math.random() * sessions.length);
        orchestrator.getSession(sessions[randomIndex]);
      },
      iterations
    );
  }

  // Message sending benchmark
  benchmarkMessageSending(orchestrator: any, iterations: number = 10000): BenchmarkResult {
    const session = orchestrator.createSession(generateTestSession());

    return benchmarkOperation(
      'Message Sending',
      () => {
        orchestrator.sendMessage(session.id, generateTestMessage());
      },
      iterations
    );
  }

  // Context management benchmark
  benchmarkContextManagement(orchestrator: any, iterations: number = 10000): BenchmarkResult {
    const session = orchestrator.createSession(generateTestSession());

    return benchmarkOperation(
      'Context Management',
      () => {
        orchestrator.setContext(session.id, { data: `test-${iterations}` });
        orchestrator.getContext(session.id);
      },
      iterations
    );
  }

  // Query operations benchmark
  benchmarkQueryOperations(orchestrator: any, iterations: number = 1000): BenchmarkResult {
    // Create multiple sessions
    for (let i = 0; i < 100; i++) {
      orchestrator.createSession(generateTestSession('agent', `Session ${i}`));
    }

    return benchmarkOperation(
      'Query Operations',
      () => {
        orchestrator.getAllSessions();
        orchestrator.getSessionsByType('agent');
        orchestrator.getSessionsByStatus('active');
        orchestrator.getWorkspaceSessions('/test');
      },
      iterations
    );
  }

  // Memory usage benchmark
  benchmarkMemoryUsage(orchestrator: any, iterations: number = 1000): BenchmarkResult {
    const memoryBefore = getMemoryUsage();

    for (let i = 0; i < iterations; i++) {
      const session = orchestrator.createSession(generateTestSession());
      orchestrator.sendMessage(session.id, generateTestMessage());
      orchestrator.setContext(session.id, { data: `memory-test-${i}` });
    }

    const memoryAfter = getMemoryUsage();

    return {
      name: 'Memory Usage',
      time: 0,
      operations: iterations,
      opsPerSecond: 0,
      memoryBefore,
      memoryAfter,
      memoryDelta: memoryAfter - memoryBefore
    };
  }

  // Run comprehensive benchmark suite
  async runFullBenchmark(): Promise<BenchmarkSuite[]> {
    const orchestrators = [
      { name: 'Ultimate Orchestrator', instance: ultimateOrchestrator },
      { name: 'Hyper-Optimized Orchestrator', instance: hyperOrchestrator },
      { name: 'Micro Orchestrator', instance: microOrchestrator },
      { name: 'Ultra-Streamlined Orchestrator', instance: ultraOrchestrator },
      { name: 'Streamlined Orchestrator', instance: orchestrator }
    ];

    this.suites = [];

    for (const { name, instance } of orchestrators) {
      console.log(`\nðŸš€ Benchmarking ${name}...`);

      const suite: BenchmarkSuite = {
        name,
        results: []
      };

      // Run benchmarks
      suite.results.push(this.benchmarkSessionCreation(instance));
      suite.results.push(this.benchmarkSessionRetrieval(instance));
      suite.results.push(this.benchmarkMessageSending(instance));
      suite.results.push(this.benchmarkContextManagement(instance));
      suite.results.push(this.benchmarkQueryOperations(instance));
      suite.results.push(this.benchmarkMemoryUsage(instance));

      this.suites.push(suite);

      // Clear orchestrator state for next test
      instance.clearAll();
    }

    return this.suites;
  }

  // Generate performance report
  generateReport(): string {
    let report = 'ðŸ”¥ Performance Benchmark Results\n';
    report += '='.repeat(60) + '\n\n';

    // Overall performance summary
    const summary = this.suites.map(suite => {
      const avgOps = suite.results
        .filter(r => r.opsPerSecond > 0)
        .reduce((sum, r) => sum + r.opsPerSecond, 0) / suite.results.filter(r => r.opsPerSecond > 0).length;

      const totalMemory = suite.results
        .reduce((sum, r) => sum + r.memoryDelta, 0);

      return {
        name: suite.name,
        avgOps: Math.round(avgOps),
        totalMemory: Math.round(totalMemory),
        score: Math.round(avgOps / (totalMemory || 1))
      };
    });

    report += 'ðŸ“Š Performance Rankings:\n';
    summary.sort((a, b) => b.score - a.score).forEach((item, index) => {
      report += `${index + 1}. ${item.name}: ${item.avgOps.toLocaleString()} ops/sec, ${item.totalMemory} bytes, Score: ${item.score}\n`;
    });

    // Detailed results
    this.suites.forEach(suite => {
      report += `\nðŸ“ˆ ${suite.name} Detailed Results:\n`;
      report += '-'.repeat(40) + '\n';

      suite.results.forEach(result => {
        const opsStr = result.opsPerSecond > 0
          ? `${Math.round(result.opsPerSecond).toLocaleString()} ops/sec`
          : 'N/A';

        report += `${result.name.padEnd(20)}: ${result.time.toFixed(2)}ms, ${opsStr}, ${result.memoryDelta} bytes\n`;
      });
    });

    return report;
  }

  // Export results to JSON
  exportResults(): string {
    return JSON.stringify(this.suites, null, 2);
  }
}

// Quick benchmark function
export async function quickBenchmark(): Promise<void> {
  const benchmark = new PerformanceBenchmark();
  await benchmark.runFullBenchmark();
  console.log(benchmark.generateReport());
}

// Run benchmark if this file is executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  quickBenchmark().catch(console.error);
}